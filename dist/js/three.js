import*as THREE from"three";import{gsap}from"gsap";import{createNoise3D}from"simplex-noise";import{randFloat}from"three/src/math/MathUtils";import{Vector2,Vector3}from"three";let renderer,scene,sizes,aspectRatio,camera,defaultColor,radius,meshPosition,mesh,scale,scaleMultiplier,scaleTl,blobScaleTl,velocities,clock,vertexNormals=!1,noise=new createNoise3D,blobScale={scale:.1};export function init(e){scene=new THREE.Scene,sizes={width:window.innerWidth,height:window.innerHeight},scaleMultiplier=Math.min(1,sizes.width/e*1.7),renderer=new THREE.WebGLRenderer({antialias:!0,alpha:!0}),renderer.setSize(sizes.width,sizes.height),document.querySelector(".blob").appendChild(renderer.domElement),aspectRatio=sizes.width/sizes.height,camera=new THREE.PerspectiveCamera(45,aspectRatio,.1,1e3),camera.position.set(6,6,6),scene.add(camera);const l=new THREE.PointLight(16777215,1);l.position.set(15,6,0),scene.add(l);const a=new THREE.PointLight(16777215,1.5);a.position.set(10,15,-20),scene.add(a);const s=new THREE.PointLight(16777215,1.2);s.position.set(-10,10,-5),scene.add(s),defaultColor=4210752,radius=1,meshPosition=new THREE.Vector3(5,0,5),camera.lookAt(meshPosition.x,meshPosition.y,meshPosition.z);const i=new THREE.TextureLoader,t=i.load("media/img/blob/coal-texture.webp"),o=i.load("media/img/blob/NormalMap.webp"),r=i.load("media/img/blob/DisplacementMap.webp"),c=i.load("media/img/blob/AmbientOcclusionMap.webp"),n=i.load("media/img/blob/SpecularMap.webp");t.anisotropy=16,scale={x:1.4,y:1,z:1.4};let m=new THREE.SphereGeometry(radius,160,160),p=new THREE.MeshPhysicalMaterial({color:defaultColor,bumpMap:t,bumpScale:0,clearcoatMap:t,clearcoatNormalMap:o,clearcoatNormalScale:new Vector2(.1,.3),displacementMap:r,displacementScale:0,roughness:.67,metalness:1,reflectivity:.79,clearcoat:.767,clearcoatRoughness:.431,flatShading:1});mesh=new THREE.Mesh(m,p),mesh.position.set(meshPosition.x,meshPosition.y,meshPosition.z),scene.add(mesh),t.dispose(),o.dispose(),r.dispose(),c.dispose(),n.dispose(),mesh.scale.x=scale.x*scaleMultiplier,mesh.scale.y=scale.y*scaleMultiplier,mesh.scale.z=scale.z*scaleMultiplier,scaleTl=gsap.timeline({repeat:-1,repeatDelay:0}),scaleTl.startTime(0),scaleTl.fromTo(mesh.scale,{x:scale.x*scaleMultiplier,y:scale.y*scaleMultiplier,z:scale.z*scaleMultiplier},{x:1.3*scale.x*scaleMultiplier,y:1*scale.y*scaleMultiplier,z:1.3*scale.z*scaleMultiplier,duration:5,ease:"expo.inOut"}).to(mesh.scale,{x:.8*scale.x*scaleMultiplier,y:1.4*scale.y*scaleMultiplier,z:.8*scale.z*scaleMultiplier,duration:5,ease:"expo.inOut"}).to(mesh.scale,{x:1.3*scale.x*scaleMultiplier,y:1*scale.y*scaleMultiplier,z:1.3*scale.z*scaleMultiplier,duration:5,ease:"expo.inOut"}).to(mesh.scale,{x:scale.x*scaleMultiplier,y:scale.y*scaleMultiplier,z:scale.z*scaleMultiplier,duration:5,ease:"expo.inOut"}),clock=new THREE.Clock,velocities={x:Array.from(Array(1),(()=>randFloat(-.5,.5))),y:Array.from(Array(1),(()=>randFloat(-.5,.5))),z:Array.from(Array(1),(()=>randFloat(-.5,.5)))},blobScaleTl=gsap.timeline({repeat:-1,repeatDelay:0}),blobScaleTl.startTime(0),blobScaleTl.fromTo(blobScale,{scale:blobScale.scale},{scale:1.6*blobScale.scale,duration:3,ease:"sine.inOut"}).to(blobScale,{scale:blobScale.scale/1.6**2,duration:3,ease:"sine.inOut"}).to(blobScale,{scale:1.6*blobScale.scale,duration:3,ease:"sine.inOut"}).to(blobScale,{scale:blobScale.scale,duration:3,ease:"sine.inOut"}),renderer.render(scene,camera),window.requestAnimationFrame(tick)}export function tick(){if(mesh){const e=clock.getDelta();mesh.rotation.x+=.3*e,mesh.rotation.y+=velocities.y[0]*e;const l=mesh.geometry.attributes.position,a=new THREE.Vector3;for(let e=0;e<l.count;e++){a.fromBufferAttribute(l,e);let s=Date.now();a.normalize();let i=mesh.geometry.parameters.radius+noise(a.x+5e-4*s,a.y+5e-4*s,a.z+5e-4*s)*blobScale.scale;a.multiplyScalar(i),l.setXYZ(e,a.x,a.y,a.z)}mesh.geometry.verticesNeedUpdate=!0,mesh.geometry.attributes.position.needsUpdate=!0,mesh.geometry.normalsNeedUpdate=!0,vertexNormals&&mesh.geometry.computeVertexNormals(),renderer.render(scene,camera),window.requestAnimationFrame(tick)}}export function stopTick(){if(mesh){renderer.dispose(),scene.clear(),mesh.geometry.dispose(),mesh.material.dispose();for(let e of scaleTl.getChildren())e.kill();for(let e of blobScaleTl.getChildren())e.kill();scaleTl.kill(),blobScaleTl.kill(),mesh=null}}